## 上下文切换



#### 概念

1. CPU 上下文（context）

   * CPU寄存器和程序计数器(PC)

   * 正常工作的核心功能之一（多任务）



2. Linux 特权等级

   内核空间（Ring 0）有最高权限，可以访问一切资源；

   用户空间（Ring 3）只能访问受限资源，可以通过系统调用进入内核；

   https://en.wikipedia.org/wiki/Protection_ring

3. **线程是调度的基本单位，进程是资源拥有的基本单位**；



#### 原理

1. 进程上下文切换

   * 特权等级切换（或者mode switch）

     用户空间通过系统调用完成资源访问 => CPU上下文切换（保存当前context，加载新context；切换两次）

     https://web.archive.org/web/20100218115342/http://www.linfo.org/context_switch.html

   * （进程）上下文切换

     > 在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；
     >
     > 而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

     上下文切换成本：(CPU, 内核态, 进程虚拟空间)save & restore, 各级 [TLB](https://en.wikipedia.org/wiki/Translation_lookaside_buffer) 缓存刷新(可能涉及IO)

   * 进程上下文调度时机

     a. 时间片耗尽，调度器切换进程；默认时间片 `/proc/sys/kernel/sched_rr_timeslice_ms`

     b. 进程资源不足时，挂起等待；

     c. 通过`sleep`之类的函数主动挂起；

     d. 存在更高优先级的进程运行；

     e. 硬件发生中断，进程会被挂起；内核开始执行中断程序；

     

2. 线程上下文切换

   * 线程 vs 进程

     a. 当进程只有一个线程时，可以认为进程就等于线程！（等同于进程上下文切换）

     b. 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。

     c. 线程也有自己的私有数据，比如栈和寄存器等；

   * 同一个进程的多线程，共享虚拟内存空间和全局变量；

   

3. 中断上下文切换

   * 中断处理会打断进程的正常调度和执行，**但中断上下文不涉及进程用户态！**只处理内核态和CPU上下文

   * 同一个CPU中，中断处理比进程拥有更高的优先级；

   

#### 总结

1. CPU上下文、系统内核上下文、进程和线程上下文、中断上下文分别是不同的抽象层次，包含了不同的运行时资源；

 	2. 上下文切换是Linux的核心功能之一，但是过多的上下文切换会带来较大的损耗，主因就是各层次上下文的保存和恢复；

